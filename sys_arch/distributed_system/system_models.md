## 1. 概要：

- 物理模型 Physical model
- 体系结构模型 Architecture model
	- 体系元素
		- Communication paradigms 沟通范例
		- 角色和职责
		- 位置
	- 体系模式
- 基础模型：Fundamental model
	- 交互模型：Interaction model
	- 故障模型：Failure model
	- 安全模型：Security model

## 2. 分布式系统设计的描述性模型：

- 物理模型：
	- 对系统最显然的描述
	- 根据计算机硬件组成及其之间的连接网络组成。
- 体系结构模型：
	- 用计算元素描述的计算和通信任务描述系统。
- 基础模型：
	- 为研究系统各个方面的抽象特点
	- 三个模型被引入了：交互模型、失败模型、安全模型

## 3. 分布式系统的困难和威胁

- 广泛不同的使用模式：
	- 系统组件主要用于不同种类的负载：例如某些网页每天被访问数百万次
	- 系统的某些部分连接很差
	- 某些应用对高带宽和低延迟有特殊要求
- 宽泛的系统场景：
	- 分布式系统容纳（accommodate）了异质性（heterogeneous）的硬件、操作系统和网络。
	- 网络性能差距很大
- 内部威胁
- 外部威胁

## 4. 物理模型

### 4.1 物理模型：

物理模型是分布式系统底层（underlying）硬件元素的标识，它从计算机系统特定的细节和运用的网络技术中抽象出来

### 4.2 基线物理模型：

- 联网计算机上的硬件和软件通过传递信息来沟通和协调其动作
- 是一种非常简单的分布式系统的物理模型

### 4.3 三代分布式系统：

- 早期的分布式系统
	- 出现（Emerged）于1970年末和1980年初，由于使用了局域网技术
	- 系统可能在以太网汇总包含10到100个节点，包含有限的互联网连接和支持设备。
- 因特网尺度的分布式系统
	- 出现在19世纪90年代，因为因特网的发展
	- ![internet_scale_distributed_system](https://blog.evernightfireworks.com/static/2019/11/internet_scale_distributed_system.png)
- 现代分布式系统
	- 移动计算的出现导致节点和位置无关
	- 需要增加功能，诸如服务发现和支持自发互操作（spontaneous interoperation）
	- 云计算和普适（ubiquitous）计算
	- 超大规模分布式系统：复杂系统，由一系列子系统组成，共同完成某个或者一些列任务。

## 5. 体系结构模型：

### 5.1 概念：

分布式系统简化和抽象出各组件的功能、跨计算网络组织组件、它们之间的相互关系，即彼此交流。

### 5.2 问题：

- 分布式系统内交流的实体有哪些？
- 它们如何沟通的，更确切的说，沟通范例是怎样的
- 在整个体系结构中，有哪些角色和职责？
- 如何映射到物理模型上？

#### 5.4 体系结构元素 - 沟通实体：

##### 5.4.1 面向系统的透视（perspective）

- 在分布式系统中典型的实体是进程
- 除了：
	- 在诸如传感器网络、不提供此类抽象的原始环境中，因此进行节点通信
	- 在大多数的环境中，进程有线程补充（supplemented），因此线程是通信的端点
	
##### 5.4.2 面向问题的透视（perspective）

- 对象：
	- 计算由多个交互对象组成，这些对象表示问题域的分解（decomposition）单位
	- 对象通过接口访问
- 组件
	- 类似（resemble）对象，它们提供了面向问题的抽象，也可以通过接口访问
	- 不仅要为他们指定（specify）接口，还要指定它们为组件实现其功能而必须存在的其它组件/接口的假设
- Web Services
	- 通过唯一资源定位符辨识软件应用
	- 支持和其他代理的交互

### 5.5 体系结构元素 - 沟通范例（paradigm）

#### 5.5.1 沟通范例的类型：

- 进程间（interprocess communication）
- 远程调用（invocation）
- 间接沟通

#### 5.5.2 进程间通信

- 在分布式系统中进程间通信的低阶支持，包括消息解析原语
- 直接访问因特网协议提供的API，支持多播

#### 5.5.3 远程调用

- 包括一系列基于在通信实体双向交换的技术
- 导致一系列远程操作、过程和方法：
	- Request-reply protocol：施加在（imposed）底层消息解析服务上以支持客户端服务器计算的模式
	- Remote Procedure calls：远程计算机进程中的过程可以像本地地址那样呼起
	- Remote method invocation：一个可呼叫对象可以调用（invoke）远程对象的方法（例如actor模型）

#### 5.5.4 间接通信

- 组通信
	- 过程：
		- 向一组收信人传递消息
		- 抽象一组表示为系统中的组标识符
		- 收件人选择性的接收发送到组中的消息
	- 两种类型
		- Broadcast
		- Multicast
	- 被用于
		- 服务的复制
		- 数据的复制
		- 服务发现
		- 事件提醒
	- 图示：
		- ![group_common](https://blog.evernightfireworks.com/static/2019/11/group_comm.png)
- 发布订阅系统
	- 过程：大量的发布者分发感兴趣的信息项（事件）给大量的消费者（订阅者）
	- 特征：
		- 通过事件传播（propagation）机制来通信
		- 通过发布订阅系统关联
		- 发送进程发布事件
		- 接收进程订阅事件并仅仅接收它们感兴趣的事件
- 消息队列：
	- 消息队列提供了一种点对点服务，在那里，生产者进程可以发送消息给指定的队列，并且消费者进程可以从队列中接受消息或者提醒

### 5.6 体系结构元素 - 角色和职责

#### 5.6.1 风格：

- 客户端、服务器
- 点对点

#### 5.6.2 客户端服务器

- 图示：
	- ![client_server_single_to_single](https://blog.evernightfireworks.com/static/2019/11/client_server_single_to_single.png)
	- ![client_server_reverse_proxy](https://blog.evernightfireworks.com/static/2019/11/client_server_reverse_proxy.png)
- 基础问题：
	- 提供了直接、相对简单的方式去分享数据和其它资源
	- 但是伸缩性糟糕,中心化问题导致尺度很难变大，包括主机的能力和连接的带宽等
	- 有多种变体，但是都难以根本性的解决问题

#### 5.6.3 点对点

- 由大量运行在不同主机上的对等（peer）进程组成（composed）
- 所有的进程的可以拥有服务端和客户端角色
- 之间的沟通模式完全依赖于应用需求
- 存储、处理、沟通、加载访问对象，都是在计算机和网络连接之间分布
- 每个对象都复制到多台计算机中，以进一步分散负载并在断开各个计算机时提供连接弹性（resilience）
- 与客户端和服务器体系结构相比、放置和检索（retrieve）单个计算机的需求更加复杂

### 5.7 体系结构元素 - 位置

#### 5.7.1 多个服务器提供服务

- 选项1
	- 服务器对服务所基于的一组对象进行分区，并在它们之间进行分类：
		- 每个服务器管理它们自己的资源
		- 用户可以使用浏览器访问任意服务器上的资源
- 选项2
	- 服务器在多个宿主上维护多副拷贝
		- NIS（Network Information Service）

#### 5.7.2 代理服务器和缓存

- 概要：缓存存储是与对象本身更近的最近使用数据对象，可能与客户端位于统一位置，也可能是被多个客户端共享的代理
- 过程：略

#### 5.7.3 移动代理：

- 类似客户端渲染
- 优点：
	- 减少网络负载
	- 克服网络延迟
	- 封装（encapsulate）协议
	- 自治（autonomously）和异步（asynchronously）地执行
	- 动态适应
	- 自然是异构的
	- 有鲁棒性并能容忍错误

## 5.8 体系结构模式

### 5.8.1 层的概念

- 垂直地组织服务为服务层
- 分布式服务可以被一个或者多个服务器进程提供，为在他们之间及他们与客户端进程之间维护一个持久的系统范围服务资源视图
- 例如：网络时间服务基于因特网和Network Time Protocol实现

#### 5.8.2 软件和硬件服务层：

示意图：
![hardware_software_services_layer](https://blog.evernightfireworks.com/static/2019/11/hardware_software_services_layer.png)

#### 5.8.3 平台：

特征：

- 向其上的层提供服务
- 在每台计算机上独立的实现
- 提供系统级别编程接口提升到一个水平，以促进（facilitate）进程之间的通信和沟通

#### 5.8.4 中间层：

概要：

- 软件层是为了掩盖异质性并且为应用程序提供方便的编程模型
- 由一组计算机中的进程或者对象表示，它们相互交互以实现通信和资源共享支持
- 与为构建可相互工作的软件提供有用的构件块有关

中间件的局限性：许多分布式应用完全依赖于重点层提供的服务来满足其对通信和数据共享的需要，例如服务发现

分布方式：

1. 垂直分布（Vertical Distribution）：Multi-Tier
	- 是一种CS架构的拓展
	- 将传统服务器的功能分布在多台服务器上
	- ![middle_layer_vert_struct](https://blog.evernightfireworks.com/static/2019/11/middle_layer_vert_struct.png)
	- ![middle_layer_vert_timeline](https://blog.evernightfireworks.com/static/2019/11/middle_layer_vert_timeline.png)
2. 水平分布：
	- 涉及（Involves）复制一台服务器的功能到多台服务器上
	- 被用来提升伸缩性（通过减少个体服务器的负载）和可靠性（通过提供冗余）

胖瘦客户端的实现：

- 解构典型的CS应用为三个部分：
	- 接口部分
	- 应用逻辑部分
	- 数据部分
- 瘦客户端实现：提供了一个最小的用户接口层、将其他部分全部留给服务器端
- 胖客户端实现：
	- 包括所有用户接口和逻辑
	- 仅仅依靠服务器来存储和提供数据
- 之间的实现会把应用逻辑或者接口以不同的方式分到客户端和服务器端

## 7. 基础模型

### 7.1 基础模型的需求

- 什么是系统的主要实体
- 它们如何交互的
- 哪些因素会影响个体（individual）和集体（collective）行为

### 7.2 需要考虑的方面

- 交互
- 失败
- 安全

### 7.3 交互模型

#### 7.3.1 沟通通道的性能

- 延迟 Latency
	- 操作系统在发送和接收时的时间消耗
	- 访问网络的延迟
	- 通过网络传输第一个比特到其目的地所花费的时间
- 带宽 Bandwidth：在给定时间内传送的数据数量
- 抖动 Jitter：传输一系列消息时间的变化

#### 7.3.2 交互模型的两种变体：

- 同步分布式系统
	- 执行每步的时间都有已知的上界和下界
	- 每个通过一个通道传输的消息都会在一个有界时间内被收到
	- 每个进程都有本地时钟，其与实时的漂移率（draft rate）界是已知的
- 异步分布式系统：以上界都不存在

#### 7.3.3 事件重排序：

### 7.4 失败模型

概念：故障模型定义了失败可能出现的方式，也就提供了对失败影响的理解：

#### 7.4.1 流程和渠道失败分类法（Taxonomy）：

- 遗漏失败（Omission failure）
- 随机失败（Arbitrary failure）
- 计时失败（Timing failure）

#### 7.4.2 失败详情：

- 遗漏失败 Omission failure
	- ![failure_model_omission_failure](https://blog.evernightfireworks.com/static/2019/11/failure_model_omission_failure.png)
- 随机失败 Arbitrary failure
	- 常常被称为拜占庭失败 Byzantine failure
	- 是最糟糕的情况
	- 解决方法：校验和，序列号
- 超时失败 Timing failure
	- 种类：
		- 进程时间超时
		- 进程表现超时
		- 通道表现超时

### 7.5 安全模型

概念：用于保护用于交互的进程和通道以及他们封装的对象免受未经授权的访问来归档

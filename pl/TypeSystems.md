# 1. 引言

类型系统的根本目的是为了防范在程序运行过程中执行错误的发生。这个非正式的说法激励了对类型系统的研究，但是需要澄清（clarification），他的准确性，首先取决于什么可以算作（constitutes）执行错误这个相当（rather）微妙（subtle）的问题，我们将详细讨论这个问题。即使解决了（settled）这个问题，没有执行错误是一个非平凡（nontrival）的属性。当这样的属性对所有的可被使用某种编程语言表达的程序的运行都成立（hold）的时候，我们说这种语言是类型健全的。事实证明（it turns out that)，为了避免错误（false）和令人尴尬的编程语言健全性的说法需要相当多（a fair amount）的仔细分析。因此（As a consequence），类型系统的分类、描述和研究已经成为一门正式的学科（discipline）。

类型系统的形式化需要精确记号和定义的发展，以及形式属性的详细证明，使人们对定义的适当性产生信心。有时，这门学科变得相当抽象。不过，我们应当始终记住（One should always remember），基本的动机是实用的（pragmatic）；抽象的东西是出于需要而产生的（have arisen out of），通常可以直接与具体（concrete）的直觉（intuition）相关。此外（moreover），形式化的技术不一定要有用和便利才被完全的应用。对类型系统原则的了解有助于避免显式和不明显的陷阱（pitfall），也能够激发语言设计的规律性（regularity）和正交性（orthogonality）。
iii. 如果开发得当，类型胸痛提供了概念性（conceptual）的工具，用以判断语言定义重要方面的充分性（adequacy）。非形式化的语言描述往往不能足够详细的说明（specify）语言的类型结构，从而无法明确（unambiguous）地实现。经常出现的情况是，不同的编译器对同一种语言实现了有轻微（sightly）不同的类型系统。此外，许多语言的类型系统被发现是类型不健全的，它们可以在尽管被类型检查器判断为可接受的情况下，使得程序崩溃。理想情况下，形式化的类型系统应该是所有类型化编程语言的一部分。这样一来（this way），类型检查算法可以根据（against）精确的规范进行毫不含糊的（unambiguously）的测量（measure）。如果可能（possible）和可行（feasible）的话，整个语言就可以被证明是类型健全的。

在这个介绍性的部分，我们提出了（present）一个关于类型、执行错误和相关概念的非正式命名法（nomenclature）。我们讨论了类型系统的预期属性和好处，回顾了类型系统如何被进行形式化。在导言中使用的术语不是完全标准的，这是由于来自不同来源的标准术语内在的不一致。一般来说，我们避免在提及运行时概念时提及类型和类型化的概念。例如，使用动态类型和动态检查而避开常见的但是有歧义的术语 —— 诸如强类型。该术语在定义术语部分做了总结。

在第二部分，我们解释了常用于描述类型系统的符号。我们回顾了判断（judgements）—— 关于程序类型化的形式化断言；类型规则（type rules） —— 判断之间的隐含牵连（implications）和推导（derivation） —— 基于类型规则的演绎。在第三部分，我们回顾了简单类型的广泛范围（spectrum），这些简单类型的类似物（analog）可以在常用语言中找到，我们还详细地介绍了他们的类型规则。在第四部分，我们介绍了一个简单但完整的命令式（imperative）语言。在第五部分，我们讨论了一些高级类型构造类型规则：多态性（polymorphism）和数据抽象。在第六部分，我们解释了如何用子类型化的概念来拓展类型系统。第七部分是对一些我们忽略（glossed over）的一些重要部分的精简评论（commentary）。在第八部分，我们讨论了类型推断问题，并介绍了我们所考虑的主要类型系统的类型推断算法。最后，第九部分是对成就和未来方向的总结。

## 执行错误

执行错误最明显的表征（symptom）是意外的软件故障（fault）的出现，例如非法指令故障或者非法内存应用故障。

然而，还有一些更微妙（subtle）种类的执行错误，他们会在没有任何直接表征的情况导致数据损坏。此外，还有一些软件故障，比如除以零或者引用nil，他们通常很难被类型系统所防范。最后，有些语言缺乏类型系统，但软件故障却不会发生。因此，我们要仔细定义我们的术语，从什么是类型开始。

## 类型化和非类型化语言

在程序执行过程中，一个程序变量可以承担（assume）一个范围的值。这样一个范围的上界称为变量的类型。例如，$Boolean$  类型在程序的每次运行过程中只应该承担布尔量的类型。如果 $x$  具有 $Boolean$ 类型，那么布尔表达式 $not(x)$ 在每一次运行中都具有合理的意义。可以给变量赋予（非平凡）类型的语言称为类型化语言。

不严格约束变量范围的语言称为非类型化语言：它们没有类型，或者等价的，有一个包含所有值的通用类型。对于这些语言，操作可以应用于不适当的参数：结果可能是固定的任意值（arbitrary），一个故障，一个异常，或者未指定的效果。纯 λ 运算运算是一种极端的不会有故障的非类型化语言案例：唯一的操作是函数的应用，而且由于所有的值都是函数，所以这种操作永远不会失败。
 
 类型系统是类型化语言的组成部分（component），它跟踪变量的类型，一般来说，是所有程序中的表达式的类型。类型系统被用来确定程序是否有良好的的行为（后文会讨论）。只有伴随着这类型系统的程序源应该被认为是真正的类型化语言的程序。其它程序源在运行前应该被丢弃。
 
 一门语言凭借着它的类型系统的存在而被类型化，无论这个类型是否真正的出现在程序的语法中。如果类型是语法的一部分，这种类型化语言是显式类型，否则就有隐式类型化的。没有主流的语言是显式类型化的，但是诸如 `ML` 和 `Haskell` 之类的语言支持编写省略（omitted）类型信息的程序片段；它们的类型系统自动的给每个程序段赋予类型。
 
## 执行错误和安全性

在两种类型的执行错误之间进行区分是很有用处的：一种会导致计算立即停止，另一种是在一段时间内没有被注意到、随后导致任意行为的错误。前者被称为捕捉的错误（trapped errors），后者称为未捕捉的错误。

一个未捕捉错误的例子是错误地访问了非法的地址，例如，在不存在运行时边界检查的情况下访问了数组的末端之后。另一种可能在任意时间之内不被发现的未捕获错误是跳转到错误的地址，那里的内存可能代表或者不代表指令流。陷阱错误的例子是除零错误和访问非法地址 —— 在很多计算机架构上，会导致计算立即停止。

如果一个程序片段不会导致未捕获的错误发生，那么它就是安全的。所有程序片段都是安全的的语言被称为安全语言。因此，安全语言排除（rule out）了最隐蔽（insidious）形式的执行错误：那些可能不被注意的错误。非类型化语言可能通过进行运行时检查来加强安全性。类型化语言可能混合地使用运行时检查和静态检查。

尽管安全是程序的重要属性，但类型化语言很少会只关注消除（elimation）未捕获的错误，类型化语言的目标通常是排除很大部分的捕获错误和未捕获错误。我们稍后会讨论这些问题。

## 执行错误和行为良好的程序

给出任意语言，我们可以将可能出现的错误的子集指定（designate）为禁止错误，包括所有的未捕获错误和部分捕获错误的子集，那么这个程序片段就被称为是行为良好的，或者相当于是行为良好的（反之则是行为不良的，或者等价于行为不良的）。特别地，一个行为良好的程序片段是安全的。当一种语言的所有（合法）程序都有良好的行为，则称为强检查。

因此，就给定的类型系统而言，对于强检查而言，以下内容是成立的。

- 不发生未捕获的错误（安全保证）
- 被指定为禁止错误的捕获错误都不会发生
- 其它的陷阱错误可能会发生，避免这些错误是程序员的责任

类型化语言通过执行静态（编译时）检查来防止不安全和不良的行为。这些语言是静态检查的，检查过程称为类型检查，执行这个检查的过程称为类型检查器。通过类型检查的程序被称为类型良好（well typed）的。否则被称为类型不良（ill typed）—— 这可能意味着它实际上是行为不良的，或者仅仅是不能保证它是行为良好的。经过静态检查的语言有ML、Java和Pascal等（可能有一些不安全的特性）。

即使是静态检查的语言，通常也必须在运行时执行测试以确保安全性。例如，数组边界在一般情况下必须进行动态测试。一门语言是静态检查的，并不意味着执行可以完全盲目的进行。

有几种语言可以利用它们的静态类型结构来进行复杂的动态测试，例如 `Simluar67` 的 `INSPECT`， `Modula-3` 的 `TYPECASE` ，`Java` 的 `instanceof` 都能对对象的运行时类型进行判别。这些语言仍然被认为是静态检查的（略显不妥），部分原因是动态类型测试是在静态类型的基础上定义的。也就是说，类型等价性的动态测试与在编译期typecheker判断类型等价性的算法是兼容的。

## 缺乏安全保障

根据我们的定义，一个行为良好的程序应当是安全的。安全是相比于良好行为更加原始、可能也是更加重要的属性。类型系统的原始目标是通过排除运行时所有的未捕获错误来确保语言的安全性。然而，多数类型系统被设计来确保更加通用的行为良好属性，和隐含的安全。因此，类型系统的声明目标通常是确保所有程序的良好行为，通过区分类型良好的和类型不良的程序。

实际上，某些静态检查语言不能够确保安全。也就是说，它们的禁止错误并不包含所有的未捕获错误。这些语言可以被委婉地（euphemistically）称为弱检查（weakly checked）或者弱类型的（weakly typed），在文献中，这意味一些不安全的操作没有被静态的检查到，而另一些检查到了。这一类语言在弱检查的程度上有很大的不同。例如，`Pascal` 只有在使用未标记的变体类型和函数参数时才是不安全的，而 `C` 语言则有许多不安全且被广泛使用的特性，如指针运算（pointer arithmetic）和转型（casting）。有趣的是，在 `C` 程序员的十条戒律中，前五条都是针对 `C` 的弱检查方面的补偿。`C` 中弱检查银帆的一些问题在 `C++` 中得到了缓解（alleviated），在 `Java` 中更是得到了解决，证实了远离弱检查的趋势。`Modula-3` 支持不安全特性，但只在明确标记为不安全的模块中支持，并防止安全模块导入不安全接口。 

大多数非类型化语言都是必要的，是完全安全的 （例如 `LISP`）。否则，在没有编译时和运行时检查以防止损坏的环境中编程将是及其令人沮丧的。汇编语言属于这种引人不快的非类型化非安全语言中的一种。

![TypeSystem Table 1](./typesystems_table_1.png "TypeSystem Table 1")


## 语言应该是安全的吗？

有些语言，例如 `C`，出于性能的考量被故意的（deliberately）设计的不安全，实现安全所需的运行时检查有时被认为太昂贵。即使在做大量静态分析的语言中，安全也是有代价的：一般来说，数组边界检查等测试不能在编译时完全消除。但仍有许多人努力设计 `C` 的安全子集，并制作开发工具，试图通过引入各种（相对昂贵的）运行时检查来安全执行 `C` 程序。
这些努力的原因主要有两个：C语言在那些基本上没有对性能要求的应用中的广泛使用，以及不安全的C程序引入的安全问题。安全问题包括由指针运算或缺乏数组边界检查引起的缓冲区溢出和欠溢，这些问题可能导致覆盖内存的任意区域，并可能被利用进行攻击。

安全性根据不同的衡量标准，比单纯的性能更具成本效益。安全性在执行错误时产生故障即停止行为，减少了调试时间。安全性保证了运行时结构的完整性，因此可以进行垃圾回收。反过来，垃圾回收又大大减少了代码大小和开发实践，代价是一些性能的牺牲。最后，安全性已经成为（emerged as）系统安全的必要基础，特别是对于加载和运行外来代码的系统（如操作系统内核和 Web 浏览器）来说。系统安全正在成为程序开发和维护中最昂贵的方面之一，而安全性可以降低这种成本。

因此，在安全语言和不安全语言之间的选择可能最终与开发和维护时间以及执行时间之间的权衡有关。虽然安全语言已经存在了几十年，但只是在最近才成为主流，首要的原因是安全问题。

## 语言是否应该被类型化？

编程语言是否应该有类型的问题仍然存在一些争论。毫无疑问，用非类型化语言编写的生产代码很难以维护。从可维护性的角度来看，即使是弱检查的不安全语言也优于安全但无类型的语言（如 `C`与 `LISP`）。以下是从工程角度提出的支持类型化语言的论点。

- 执行的经济性。类型信息最早在编程中引入的目的是，提高数值计算的代码生成和运行时间效率，例如在 `FORTRAN` 和 `ML` 中，准确的类型信息消除了对指针解引用的空检查的需要。一般来说，在编译时准确的类型信息会导致在运行时应用适当的操作，而不需要进行昂贵的测试。
- 小规模开发的经济性。当一个类型系统设计得很好时，类型检查可以捕捉到很大一部分（farction）常规（routing）编程错误，从而消除了冗长（lengthy）的调试环节。发生的错误更容易调试，只是因为已经排除了大类的其他错误。此外，有经验的程序员采用一种编码风格，使得一些逻辑错误显示为类型检查错误：他们将类型检查器作为开发工具。例如，当一个字段的不变量发生变化时，即使它的类型不变，也要改变它的名称，这样就可以得到它所有旧用途的错误报告。
- 编译的经济性。例如在 `Modula-2` 和 `Ada` 中，类型信息可以组织成程序模块的接口。然后，模块之间可以独立编译，每个模块只依赖于其他模块的接口。因为至少在接口稳定的情况下，一个模块的改变不会导致其他模块被重新编译，导致大型系统的编译效率更高。
- 大规模开发的经济性。接口和模块对于代码开发具有方法上的优势。大型程序员团队可以协商（negotiate）好要实现的接口，然后分别着手实现相应的代码片段。代码块之间的依赖性最小化，代码可以在局部重新排列，而不用担心全局影响。(这些好处也可以通过非形式化的接口规范来实现，但在实践中，类型检查对验证规范的遵守情况有很大的帮助。)
- 安全领域的开发和维护的经济性。安全是不仅是消除缓冲区溢出等安全漏洞的必要条件，也是消除其他灾难性（catastrophic）安全漏洞（breaches）的必要条件。这里有一个典型的例子：只有有一个方法，能够将一个整数转型成一个指针类型（或对象类型）的值，无论该方法是多么曲折（convoluted），那么整个系统就会受到损害（compromised）。如果这一点是可能的，那么攻击者就可以访问系统中任何地方的任何数据，甚至是在一个其他类型语言的范围内，根据附加选择的任何类型来查看数据。另一种有用的（但不是必须的）技术是将一个给定的类型指针转换成一个整数，然后再转换成一个不同类型的指针。如上所述，无论是在维护方面，也可能在整体执行效率方面，消除这些安全问题的最经济有效的方法，都是采用类型化语言。不过，安全问题在系统的各个层面都是一个问题：类型化语言是一个很好的基础，但不是一个完整的解决方案。
- 语言特征的经济性。类型构造自然是以正交的方式构成的。例如，在 `Pascal` 中，一个数组可以模拟二维数组；在 `ML` 中，一个具有单个参数的过程是 `n` 个参数的元组，可以模拟一个有 `n` 个参数的过程。因此，类型系统促进了语言特征的正交性，从而倾向于降低编程语言的复杂性。

## 类型系统的预期属性

在本章的其余部分，我们是在这样的假设下进行的：语言应该既安全又类型化，因此应该采用类型系统。在对类型系统的研究中，我们不区分有陷阱的错误和无陷阱的错误，也不区分安全和良好的行为：我们专注于良好的行为，我们把安全作为一种隐含的属性。

类型，正如编程语言中通常所希望的那样，具有实用性的特点，使它们与其他类型的程序注释不同。一般来说，关于程序行为的注释可以从非正式的注释到受定理证明的形式化规范。类型位于这个范围（spectrum）的中间：它们比程序注释更精确，比形式化规范更容易加工。以下是任何类型系统所期望的基本属性：

- 类型系统应该是可以决定性地验证（decidably verifiable）的：应该有一种算法（称为类型检查算法），可以确保程序的行为良好。类型系统的目的不是简单地陈述（state）程序员的意图（intentions），而是在执行错误发生之前主动捕捉执行错误。任意的形式化规范不具备这些特性）。
- 类型系统应该是透明的：程序员应该能够轻易地预测一个程序是否会进行类型检查。如果它没有进行类型检查，失败的原因应该是不言而喻（self-evident）的。（自动定理证明不具备这些特性）。
- 类型系统应是可执行（enforceable）的：类型声明应尽可能地进行静态检查，否则应进行动态检查。类型声明和它们相关的程序之间的一致性（consistency）应该得到常规的验证。(程序注释和惯例不具有这些属性。)

## 类型系统如何进行形式化

正如我们已经讨论过的，类型系统被用来定义好类型的概念，它本身就是良好行为（包括安全）的静态近似。安全性由于故障即停止行为而有利于调试，并通过保护运行时结构实现垃圾收集。良好类型通过在运行前捕获执行错误，进一步促进了程序开发。

但是，我们如何保证类型良好的程序真的是行为良好的呢？也就是说，我们如何保证语言的类型规则不会意外地让行为不佳的程序通过？

形式化类型系统是程序规范中描述的非正式类型系统的数学符号化。一旦一个类型系统被形式化，我们就可以尝试证明一个类型合理性定理，说明类型良好的程序表现良好。如果这样的健全性定理成立，我们就说类型系统是健全的。（一个类型化语言的所有程序的良好行为和它的类型系统的健全性是同一个意思）。

为了将类型系统形式化，并证明健全性定理，我们必须在本质上将整个有关语言形式化，正如我们现在所勾画的那样。

形式化编程语言的第一步是描述其语法。对于大多数感兴趣的语言来说，这可以简化为描述类型和项的语法。类型表达的是关于程序的静态知识，项（语句、表达式和其他程序片段）表达的是算法行为。
 
 下一步是定义语言的范围规则，它明确地将标识符的出现与它们的绑定位置（标识符被声明的位置）联系起来。类型化语言所需要的范围定义总是静态的，也就是说，标识符的绑定位置必须在运行前确定。绑定位置通常可以纯粹从语言的语法中确定，而不需要任何进一步的分析；静态范围定义就被称为词法范围定义。缺乏静态范围的称为动态范围。
 
 可以通过定义程序片段的自由变量集来正式指定作用域（这涉及到如何通过声明来指定变量的约束）。然后就可以定义相关的类型或项替代（subtitution）自由变量的概念。
 
 这一切都解决后，我们可以继续定义语言的类型规则。有些语言还要求在类型之间有一个 `A<:B` 的子类型的关系，并且经常有一个 `A=B` 的类型等价的关系。一种语言的类型规则的集合形成了它的类型系统。具有类型系统的语言称为类型语言。
 
 如果不首先引入另一个在语言语法中没有体现的基本要素：静态类型环境，类型规则就无法形式化。这些环境在处理程序片段的过程中用来记录自由变量的类型；它们与编译器在类型检查阶段的符号表紧密对应。类型规则总是针对被类型检查的片段的静态环境来制定。例如，$has-type$ 关系$M:A$ 与静态类型环境 $\Gamma$ 相关联，该环境中包含了 $M$ 和 $A$ 的自由变量的信息，该关系全文写为 $Γ \vdash M:A$，意思是 $M$ 在环境 $\Gamma$ 中具有类型 $A$。
 
 形式化语言的最后一步是将其语义定义为项和结果集合之间的 `has-value` 关系。这种关系的形式在很大程度上取决于所采用的语义学风格。在任何情况下，语言的语义和类型系统都是相互关联的：项的类型和其结果的类型应该是相同的（或适当相关的）；这就是健全性定理的本质。
 
 类型系统的基本概念几乎（virtual）适用于所有的计算范式（paradigms）（函数式、命令式、并发式等）。对于不同的范式，个别类型规则往往可以不加改变地采用。例如，无论语义是按名调用还是按值调用，或者是正交的函数式或命令式，函数的基本类型规则都是相同的。
 
 在本章中，我们独立于语义来讨论类型系统。但应该理解，最终类型系统必须与语义相关，而且对于该语义来说，健全性应该是成立的。可以这么（Suffice it to say ），结构操作语义学的技术统一处理了大量的编程范式集合，并且与本章中发现的处理方法非常吻合。
 
 ## 类型等同性
 
 如上所述，大多数非平凡类型系统都需要定义一个关于类型等价的关系等价类型。这是在定义编程语言时的一个重要问题：什么时候分开写的类型表达式是等价的？例如，考虑两个不同的类型名称，它们已经与相似的类型相关联。
 
 $$
 \begin{aligned}
 type X = Bool \\
 type Y = Bool
 \end{aligned}
 $$
 
 如果类型名 `X` 和 `Y` 因与类似类型相关联而匹配（match by virtue），我们就有结构等价性（structural equivalence）。如果它们由于是不同的类型名（不看关联类型）而不匹配，我们就有按名等价（by-name equivalence）。

在实践中，大多数语言都使用结构等价和按名等价的混合方式。纯粹的结构等价性可以通过类型规则轻松而精确地定义，而按名等价性则更难确定（pin down），而且通常具有算法的味道。当类型数据必须通过网络存储或传输时，结构等价性具有独特的优势；相比之下，按名等价性不能轻易处理在时间或空间上分别开发和编译的交互程序。

我们在下面的内容中假定结构等同（尽管这个问题并不经常出现）。正如 `Modula-3` 机制所证明的那样，结构等价可以获得令人满意的按名称等价的模拟。
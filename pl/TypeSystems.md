# 1. 引言

类型系统的根本目的是为了防范在程序运行过程中执行错误的发生。这个非正式的说法激励了对类型系统的研究，但是需要澄清（clarification），他的准确性，首先取决于什么可以算作（constitutes）执行错误这个相当（rather）微妙（subtle）的问题，我们将详细讨论这个问题。即使解决了（settled）这个问题，没有执行错误是一个非平凡（nontrival）的属性。当这样的属性对所有的可被使用某种编程语言表达的程序的运行都成立（hold）的时候，我们说这种语言是类型健全的。事实证明（it turns out that)，为了避免错误（false）和令人尴尬的编程语言健全性的说法需要相当多（a fair amount）的仔细分析。因此（As a consequence），类型系统的分类、描述和研究已经成为一门正式的学科（discipline）。

类型系统的形式化需要精确记号和定义的发展，以及形式属性的详细证明，使人们对定义的适当性产生信心。有时，这门学科变得相当抽象。不过，我们应当始终记住（One should always remember），基本的动机是实用的（pragmatic）；抽象的东西是出于需要而产生的（have arisen out of），通常可以直接与具体（concrete）的直觉（intuition）相关。此外（moreover），形式化的技术不一定要有用和便利才被完全的应用。对类型系统原则的了解有助于避免显式和不明显的陷阱（pitfall），也能够激发语言设计的规律性（regularity）和正交性（orthogonality）。
iii. 如果开发得当，类型胸痛提供了概念性（conceptual）的工具，用以判断语言定义重要方面的充分性（adequacy）。非形式化的语言描述往往不能足够详细的说明（specify）语言的类型结构，从而无法明确（unambiguous）地实现。经常出现的情况是，不同的编译器对同一种语言实现了有轻微（sightly）不同的类型系统。此外，许多语言的类型系统被发现是类型不健全的，它们可以在尽管被类型检查器判断为可接受的情况下，使得程序崩溃。理想情况下，形式化的类型系统应该是所有类型化编程语言的一部分。这样一来（this way），类型检查算法可以根据（against）精确的规范进行毫不含糊的（unambiguously）的测量（measure）。如果可能（possible）和可行（feasible）的话，整个语言就可以被证明是类型健全的。

在这个介绍性的部分，我们提出了（present）一个关于类型、执行错误和相关概念的非正式命名法（nomenclature）。我们讨论了类型系统的预期属性和好处，回顾了类型系统如何被进行形式化。在导言中使用的术语不是完全标准的，这是由于来自不同来源的标准术语内在的不一致。一般来说，我们避免在提及运行时概念时提及类型和类型化的概念。例如，使用动态类型和动态检查而避开常见的但是有歧义的术语 —— 诸如强类型。该术语在定义术语部分做了总结。

在第二部分，我们解释了常用于描述类型系统的符号。我们回顾了判断（judgements）—— 关于程序类型化的形式化断言；类型规则（type rules） —— 判断之间的隐含牵连（implications）和推导（derivation） —— 基于类型规则的演绎。在第三部分，我们回顾了简单类型的广泛范围（spectrum），这些简单类型的类似物（analog）可以在常用语言中找到，我们还详细地介绍了他们的类型规则。在第四部分，我们介绍了一个简单但完整的命令式（imperative）语言。在第五部分，我们讨论了一些高级类型构造类型规则：多态性（polymorphism）和数据抽象。在第六部分，我们解释了如何用子类型化的概念来拓展类型系统。第七部分是对一些我们忽略（glossed over）的一些重要部分的精简评论（commentary）。在第八部分，我们讨论了类型推断问题，并介绍了我们所考虑的主要类型系统的类型推断算法。最后，第九部分是对成就和未来方向的总结。

## 执行错误

执行错误最明显的表征（symptom）是意外的软件故障（fault）的出现，例如非法指令故障或者非法内存应用故障。

然而，还有一些更微妙（subtle）种类的执行错误，他们会在没有任何直接表征的情况导致数据损坏。此外，还有一些软件故障，比如除以零或者引用nil，他们通常很难被类型系统所防范。最后，有些语言缺乏类型系统，但软件故障却不会发生。因此，我们要仔细定义我们的术语，从什么是类型开始。

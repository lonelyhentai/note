# 1. 引言

类型系统的根本目的是为了防范在程序运行过程中执行错误的发生。这个非正式的说法激励了对类型系统的研究，但是需要澄清（clarification），他的准确性，首先取决于什么可以算作（constitutes）执行错误这个相当（rather）微妙（subtle）的问题，我们将详细讨论这个问题。即使解决了（settled）这个问题，没有执行错误是一个非平凡（nontrival）的属性。当这样的属性对所有的可被使用某种编程语言表达的程序的运行都成立（hold）的时候，我们说这种语言是类型健全的。事实证明（it turns out that)，为了避免错误（false）和令人尴尬的编程语言健全性的说法需要相当多（a fair amount）的仔细分析。因此（As a consequence），类型系统的分类、描述和研究已经成为一门正式的学科（discipline）。

类型系统的形式化需要精确记号和定义的发展，以及形式属性的详细证明，使人们对定义的适当性产生信心。有时，这门学科变得相当抽象。不过，我们应当始终记住（One should always remember），基本的动机是实用的（pragmatic）；抽象的东西是出于需要而产生的（have arisen out of），通常可以直接与具体（concrete）的直觉（intuition）相关。此外（moreover），形式化的技术不一定要有用和便利才被完全的应用。对类型系统原则的了解有助于避免显式和不明显的陷阱（pitfall），也能够激发语言设计的规律性（regularity）和正交性（orthogonality）。
iii. 如果开发得当，类型胸痛提供了概念性（conceptual）的工具，用以判断语言定义重要方面的充分性（adequacy）。非形式化的语言描述往往不能足够详细的说明（specify）语言的类型结构，从而无法明确（unambiguous）地实现。经常出现的情况是，不同的编译器对同一种语言实现了有轻微（sightly）不同的类型系统。此外，许多语言的类型系统被发现是类型不健全的，它们可以在尽管被类型检查器判断为可接受的情况下，使得程序崩溃。理想情况下，形式化的类型系统应该是所有类型化编程语言的一部分。这样一来（this way），类型检查算法可以根据（against）精确的规范进行毫不含糊的（unambiguously）的测量（measure）。如果可能（possible）和可行（feasible）的话，整个语言就可以被证明是类型健全的。

在这个介绍性的部分，我们提出了（present）一个关于类型、执行错误和相关概念的非正式命名法（nomenclature）。我们讨论了类型系统的预期属性和好处，回顾了类型系统如何被进行形式化。在导言中使用的术语不是完全标准的，这是由于来自不同来源的标准术语内在的不一致。一般来说，我们避免在提及运行时概念时提及类型和类型化的概念。例如，使用动态类型和动态检查而避开常见的但是有歧义的术语 —— 诸如强类型。该术语在定义术语部分做了总结。

在第二部分，我们解释了常用于描述类型系统的符号。我们回顾了判断（judgements）—— 关于程序类型化的形式化断言；类型规则（type rules） —— 判断之间的隐含牵连（implications）和推导（derivation） —— 基于类型规则的演绎。在第三部分，我们回顾了简单类型的广泛范围（spectrum），这些简单类型的类似物（analog）可以在常用语言中找到，我们还详细地介绍了他们的类型规则。在第四部分，我们介绍了一个简单但完整的命令式（imperative）语言。在第五部分，我们讨论了一些高级类型构造类型规则：多态性（polymorphism）和数据抽象。在第六部分，我们解释了如何用子类型化的概念来拓展类型系统。第七部分是对一些我们忽略（glossed over）的一些重要部分的精简评论（commentary）。在第八部分，我们讨论了类型推断问题，并介绍了我们所考虑的主要类型系统的类型推断算法。最后，第九部分是对成就和未来方向的总结。

## 执行错误

执行错误最明显的表征（symptom）是意外的软件故障（fault）的出现，例如非法指令故障或者非法内存应用故障。

然而，还有一些更微妙（subtle）种类的执行错误，他们会在没有任何直接表征的情况导致数据损坏。此外，还有一些软件故障，比如除以零或者引用nil，他们通常很难被类型系统所防范。最后，有些语言缺乏类型系统，但软件故障却不会发生。因此，我们要仔细定义我们的术语，从什么是类型开始。

## 类型化和非类型化语言

在程序执行过程中，一个程序变量可以承担（assume）一个范围的值。这样一个范围的上界称为变量的类型。例如，$Boolean$  类型在程序的每次运行过程中只应该承担布尔量的类型。如果 $x$  具有 $Boolean$ 类型，那么布尔表达式 $not(x)$ 在每一次运行中都具有合理的意义。可以给变量赋予（非平凡）类型的语言称为类型化语言。

不严格约束变量范围的语言称为非类型化语言：它们没有类型，或者等价的，有一个包含所有值的通用类型。对于这些语言，操作可以应用于不适当的参数：结果可能是固定的任意值（arbitrary），一个故障，一个异常，或者未指定的效果。纯 λ 运算运算是一种极端的不会有故障的非类型化语言案例：唯一的操作是函数的应用，而且由于所有的值都是函数，所以这种操作永远不会失败。
 
 类型系统是类型化语言的组成部分（component），它跟踪变量的类型，一般来说，是所有程序中的表达式的类型。类型系统被用来确定程序是否有良好的的行为（后文会讨论）。只有伴随着这类型系统的程序源应该被认为是真正的类型化语言的程序。其它程序源在运行前应该被丢弃。
 
 一门语言凭借着它的类型系统的存在而被类型化，无论这个类型是否真正的出现在程序的语法中。如果类型是语法的一部分，这种类型化语言是显式类型，否则就有隐式类型化的。没有主流的语言是显式类型化的，但是诸如 `ML` 和 `Haskell` 之类的语言支持编写省略（omitted）类型信息的程序片段；它们的类型系统自动的给每个程序段赋予类型。
 
## 执行错误和安全性

在两种类型的执行错误之间进行区分是很有用处的：一种会导致计算立即停止，另一种是在一段时间内没有被注意到、随后导致任意行为的错误。前者被称为捕捉的错误（trapped errors），后者称为未捕捉的错误。

一个未捕捉错误的例子是错误地访问了非法的地址，例如，在不存在运行时边界检查的情况下访问了数组的末端之后。另一种可能在任意时间之内不被发现的未捕获错误是跳转到错误的地址，那里的内存可能代表或者不代表指令流。陷阱错误的例子是除零错误和访问非法地址 —— 在很多计算机架构上，会导致计算立即停止。

如果一个程序片段不会导致未捕获的错误发生，那么它就是安全的。所有程序片段都是安全的的语言被称为安全语言。因此，安全语言排除（rule out）了最隐蔽（insidious）形式的执行错误：那些可能不被注意的错误。非类型化语言可能通过进行运行时检查来加强安全性。类型化语言可能混合地使用运行时检查和静态检查。

尽管安全是程序的重要属性，但类型化语言很少会只关注消除（elimation）未捕获的错误，类型化语言的目标通常是排除很大部分的捕获错误和未捕获错误。我们稍后会讨论这些问题。

## 执行错误和行为良好的程序

给出任意语言，我们可以将可能出现的错误的子集指定（designate）为禁止错误，包括所有的未捕获错误和部分捕获错误的子集，那么这个程序片段就被称为是行为良好的，或者相当于是行为良好的（反之则是行为不良的，或者等价于行为不良的）。特别地，一个行为良好的程序片段是安全的。当一种语言的所有（合法）程序都有良好的行为，则称为强检查。

因此，就给定的类型系统而言，对于强检查而言，以下内容是成立的。

- 不发生未捕获的错误（安全保证）
- 被指定为禁止错误的捕获错误都不会发生
- 其它的陷阱错误可能会发生，避免这些错误是程序员的责任

类型化语言通过执行静态（编译时）检查来防止不安全和不良的行为。这些语言是静态检查的，检查过程称为类型检查，执行这个检查的过程称为类型检查器。通过类型检查的程序被称为类型良好（well typed）的。否则被称为类型不良（ill typed）—— 这可能意味着它实际上是行为不良的，或者仅仅是不能保证它是行为良好的。经过静态检查的语言有ML、Java和Pascal等（可能有一些不安全的特性）。

即使是静态检查的语言，通常也必须在运行时执行测试以确保安全性。例如，数组边界在一般情况下必须进行动态测试。一门语言是静态检查的，并不意味着执行可以完全盲目的进行。

有几种语言可以利用它们的静态类型结构来进行复杂的动态测试，例如 `Simluar67` 的 `INSPECT`， `Modula-3` 的 `TYPECASE` ，`Java` 的 `instanceof` 都能对对象的运行时类型进行判别。这些语言仍然被认为是静态检查的（略显不妥），部分原因是动态类型测试是在静态类型的基础上定义的。也就是说，类型等价性的动态测试与在编译期typecheker判断类型等价性的算法是兼容的。

# 正则表达透视

## 执行机制

执行流程如下：

1. 开始
2. 预编译（可选）
3. 编译
4. 引擎传动
5. 检查元素
6. 是否完成匹配
    - 是，结束
    - 否，转向 7
7. 向下一个字符移动
    - 不存在下一个字符，失败
    - 存在下一个字符，转向 4

在模板正则表达式需要多次被使用时，可以使用预编译来进行优化，避免多次编译。例如在 python 中：

- `re.compile(pattern)` 预编译返回 `pattern` 对象，后续代码中可以直接引用
- `re.match(pattern, text)` 现场编译，会有编译缓存，但是需要访问缓存取出

## 引擎设计和陷阱

`DFA`、`NFA` 等内容参见形式语言和自动机，略。

正则表达式可以简单的转换为 `NFA`，`NFA` 可以通过子集构造法或者乘积构造法转换为 `DFA`，或者直接利用函数调用组合子或者栈结构模拟 `NFA` 的回溯即可。

经过精心设计的结构，可能使得正则引擎反复到达串的最后，然后失败并回溯，导致资源的过高使用。

## 优化

### 应用前优化

- 编译缓存
- 避免重新编译
- 变量插值
- 预查询必须的字符，没有则不尝试匹配

### 传动引擎优化

- 使用行首匹配和行尾匹配的 `^` 和 `$` 来确保精准匹配
- 内嵌文字字符串检查优化，检查特定位置的字符串

### 表达式本身优化

- 不要滥用括号，如在与闭包结合使用的场景，正则表达式可能会干扰优化
- 不要滥用字符组匹配
- 量词的等价转换，如 `a{3} 比 aaa` 快
- 拆分表达式
- 使用非捕获型括号，如 `(?=...)`
- 分支优化，常用的选择项放在前面，使得可以较快的匹配到
- 少用贪婪模式
- 谨慎使用 `.` 和 `*` 等会导致过多匹配、贪婪模式、频繁回溯的符号